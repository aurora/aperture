<html>

<head>
	<title>Aperture - Tutorials - General Structure</title>
	<link rel="stylesheet" type="text/css" href="../style/default/documentation.css">
</head>

<body>

<h1>General Structure of Aperture Components</h1>

<p>
Aperture consists of a number of APIs that each fulfill a type of service, e.g. text and
metadata extraction, crawling of an information source or identifying a file's MIME type.
The code involved in implementing and managing such a service is typically organized
in a particular way. Once you know how this structure works,&nbsp; you will be better able to quickly
find your way around using Aperture or extending Aperture. The following image 
shows how the components work together in a typical application:</p>
<p align="center">
<img border="0" src="aperture-architecture.png" width="952" height="537"></p>
<p align="left">
Aperture starts with the existing data sources of you, a file-system with files, 
am IMAP server or other sources. For each of this sources, Aperture provides a 
crawler, which reads data from the source and converts it to a standardized 
format - RDF. RDF is like a Java Hashset, but with more possibilities, see here. 
Once the data is converted by the crawler, it is passed to a crawler handler. 
The crawler handler is the component you will write to use Aperture. You, as 
Aperture user, decide now what happens with the data. If the crawler found a 
binary file (like a HTML document), you can use Aperture to extract metadata and 
the fulltext of this file. To do this, the MimeTypeIdentifier helps you to 
detect which MIME type the file has. Based on the MIME type (for example, text/html), 
Aperture provides you with various Extractors, these are objects that can 
extract metadata from a binary file. For HTML, the HtmlExtractor does this task, 
Aperture knows how to find the right Extractor, you use the ExtractorRegistry 
for that. Finally, you have all metadata of&nbsp; the file that was crawled from 
the filesystem, you can store this now in your search engine. We used the 
LuceneSail search engine, you can use Lucene, MySQL, or whatever storage you 
want.</p>

<h2>
The APIs</h2>

<p>
The heart of each service is an API, usually a Java interface, whose methods perform the
embodied service. For example, the Extractor interface defines an extract method that
performs full-text and metadata extraction on an InputStream accessing a document of
a specific MIME type. A specific implementation such as HtmlExtractor implements this
service for HTML documents.
</p>

<p>
Each service API is generally accompanied by a factory API, such as ExtractorFactory. Each API
implementation should come with a factory implementation. The purpose of this factory is
twofold:
</p>

<ul>
<li>It should be able to return the capabilities of that particular service
implementation, letting you choose the best implementation for a specific job.</li>
<li>It should be able to return an instance of the service API, fulfulling these
capabilities.</li>
</ul>

<p>
For example, ExtractorFactory defines a getSupportedMimeTypes method that returns the set
of MIME types supported by a particular Extractor implementation. Also, it defines a get
method that returns an Extractor instance ready for use. ExtractorFactory does not specify whether a
new or shared instance is returned, that is up to the implementor to decide.
HtmlExtractorFactory's getSupportedMimeTypes method returns a set containing "text/html"
and other known HTML(-like) MIME types and returns a new HtmlExtractor on each get() invocation.
</p>

<p>
When implementing, you should take care that implementations of the factory are as light-weight
as possible. Any expensive initialization operations needed for a service implementation
should happen during the get operation or in some other kind of lazy way.
</p>

<p>
In order to keep track of all available implementations of a service, a registry is used.
For example, ExtractorRegistry serves as a container for all known ExtractorFactories.
When asked for all factories supporting a specific MIME type, you will get a set of all
ExtractorFactories whose supported MIME type contain the specified MIME type. You can then use
additional measures to select the best one or simply take the first one available.
</p>

<p>
This service-factory-registry approach has been inspired by <a href="http://www.osgi.org/">OSGi</a>,
a platform for using service-oriented architectures inside a Java application.
In an OSGi application using Aperture, the HtmlExtractor and its factory would be bundled
as a jar file together with a class implementing OSGi's BundleActivator interface. The latter class contains
a method that is executed as soon as this bundle is presented to the system.
This BundleActivator would then lookup the ExtractorRegistry instance of the system and register its factory at
that registry. That's the reason why factory instantiation should be as cheap as possible, as
they may all be instantiated during startup.
</p>

<p>
For those applications not based on OSGi, a default implementation of a
registry is also available. For example, DefaultExtractorRegistry contains by default
an instance of every ExtractorFactory available in Aperture. When you want to
differentiate from this set, e.g. because you have your own set implementations, you can:
</p>

<ul>
<li>create an instance of ExtractorRegistryImpl (the super class of DefaultExtractorRegistry
that does not automatically populate itself) and populate it manually with ExtractorFactories,</li>
<li>add extra factories to the DefaultExtractorRegistry, or</li>
<li>take a look at the XML file that DefaultExtractorRegistry uses to get the ExtractorFactory
class names and specify your own configuration file instead.</li>
</ul>

<p>
The image below shows an overview of the APIs and their dependencies of the Extractor example:
</p>

<p align="center">
<img src="component-architecture.png">
</p>

</body>

</html>