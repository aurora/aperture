<html>

<head>
	<title>Aperture - Tutorials - General Structure</title>
	<link rel="stylesheet" type="text/css" href="../style/default/documentation.css">
</head>

<body>

<h1>General Structure of Aperture Components</h1>

<p>
Aperture consists of a number of APIs that each fulfill a type of service, e.g. text and
metadata extraction, crawling of an information source or identifying a file's MIME type.
The code involved in implementing and managing such a service is typically organized
in a particular way. Once you know how this structure works,&nbsp; you will be better able to quickly
find your way around using Aperture or extending Aperture. The following image 
shows how the components work together in a typical application:</p>
<p align="center">
<img border="0" src="aperture-architecture.png" width="952" height="537"></p>

<p align="left">
Aperture operates on existing data sources, many types are supported out of the
box (like file-systems with files or IMAP servers), other may easily be added.
For each of these data source types, Aperture provides a 
crawler, which reads data from the source and converts it to a standardized 
format - <a href="http://www.w3.org/RDF/">RDF</a>. 
A the most basic level <a href="http://www.w3.org/RDF/">RDF</a> is a data structure
comparable to a Java Hashset, but with much more possibilities, see 
<a href="http://www.w3.org/RDF/">here</a>. 
</p>

<p align="left">
Once the data is converted by the crawler, it is passed to a crawler handler. 
The crawler handler is the component you will write to use Aperture in your
application. You, as Aperture user, decide now what happens with the data. 
</p>

<p align="left">
When the crawler finds a 
file (like a HTML document), you can use Aperture to extract metadata and 
the full text from it. To do this, you need to take following steps. 
</p>

<ol>
<li>Use MimeTypeIdentifier to detect the MIME type of the file</li>
<li>When you have the MIME Type (for example, text/html), you can use it
to obtain an appropriate Extractor. Aperture provides you with various 
Extractors, these are objects that can extract metadata from a binary file. 
For HTML files, the HtmlExtractor does the job. Aperture knows how to find 
the right Extractor, you use the ExtractorRegistry for that.</li>
<li>Let extractor extract the metadata from the binary stream</li>
<li>Finally, you have all metadata from the file, you can do whatever you need
for you application. You may store it in an RDF database, or feed the text to
a search engine, (or do both in the same time with the aid of LuceneSail). 
You can use Lucene, MySQL, files or any other storage. It's all up to your
imagination.</li>
</ol>


<h2>
The APIs</h2>

<p>
Aperture architecture is built from services. This makes it fit nicely in other
service-oriented applications. The main services are:
<ul>
<li><a href="crawlers.html">Crawlers</a></li>
<li><a href="extractors.html">Extractors</a></li>
<li><a href="accessors.html">Data Accessors</a></li>
<li><a href="mimetypes.html">Mime type identifiers</a></li>
<li><a href="link-extractors.html">Link extractors</a></li>
</ul>
</p>

<p>
The heart of each service is an API, usually a Java interface, whose methods perform the
embodied service. For example, the Extractor interface defines an extract method that
performs full-text and metadata extraction on an InputStream accessing a document of
a specific MIME type. A specific implementation such as HtmlExtractor implements this
service for HTML documents.
</p>

<p>
Each service API is generally accompanied by a factory API, such as ExtractorFactory. Each API
implementation should come with a factory implementation. The purpose of this factory is
twofold:
</p>

<ul>
<li>It should be able to return the capabilities of that particular service
implementation, letting you choose the best implementation for a specific job.</li>
<li>It should be able to return an instance of the service API, fulfulling these
capabilities.</li>
</ul>

<p>
For example, ExtractorFactory defines a getSupportedMimeTypes method that returns the set
of MIME types supported by a particular Extractor implementation. Also, it defines a get
method that returns an Extractor instance ready for use. ExtractorFactory does not specify whether a
new or shared instance is returned, that is up to the implementor to decide.
HtmlExtractorFactory's getSupportedMimeTypes method returns a set containing "text/html"
and other known HTML(-like) MIME types and returns a new HtmlExtractor on each get() invocation.
</p>

<p>
When implementing, you should take care that implementations of the factory are as light-weight
as possible. Any expensive initialization operations needed for a service implementation
should happen during the get operation or in some other kind of lazy way.
</p>

<p>
In order to keep track of all available implementations of a service, a registry is used.
For example, ExtractorRegistry serves as a container for all known ExtractorFactories.
When asked for all factories supporting a specific MIME type, you will get a set of all
ExtractorFactories whose supported MIME type contain the specified MIME type. You can then use
additional measures to select the best one or simply take the first one available.
</p>

<p>
This service-factory-registry approach has been inspired by <a href="http://www.osgi.org/">OSGi</a>,
a platform for using service-oriented architectures inside a Java application.
In an OSGi application using Aperture, the HtmlExtractor and its factory would be bundled
as a jar file together with a class implementing OSGi's BundleActivator interface. 
The activator will be responsible for letting the rest of the system know
that an ExtractorFactory has appeared and is ready to use. The Factory would
be detected by a Registry. Any application using the registry will now 
transparently begin to use the new factory. That's the reason why factory 
instantiation should be as cheap as possible, as
they may all be instantiated during startup.
</p>

<p>
For 'normal' java applications, not based on OSGi, a default implementation of a
registry is also available. For example, DefaultExtractorRegistry contains
an instance of every ExtractorFactory available in Aperture. When you want to
use a different set, e.g. because you have your own set implementations, you can:
</p>

<ul>
<li>create an instance of ExtractorRegistryImpl (the super class of DefaultExtractorRegistry
that does not automatically populate itself) and populate it manually with ExtractorFactories,</li>
<li>add extra factories to the DefaultExtractorRegistry, or</li>
<li>take a look at the XML file that DefaultExtractorRegistry uses to get the ExtractorFactory
class names and specify your own configuration file instead.</li>
</ul>

<p>
The image below shows an overview of the APIs and their dependencies of the Extractor example:
</p>

<p align="center">
<img src="component-architecture.png">
</p>

</body>

</html>