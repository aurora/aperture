<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>  
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <meta name="author" content="Leo Sauermann, Christiaan Fluit">
  <meta name="keywords" content="aperture, rdf, data">
  <title>Aperture Architecture</title>
  <script type="text/javascript"></script>
</head>

<body>

<h1>Background Information about Factories</h1>
(Christiaan Fluit)
<p>
Each XYZ API interface comes with its own XYZFactory interface whose get()
method embeds the knowledge of how an instance of this type is best
instantiated. For example, it may always return the same statically held
instance, return new instances on each get() call, temporarily cached shared
instances using WeakReferences, etc.
</p>
<p>
Examples: a PlainTextExtractorFactory always returns the same
PlainTextExtractor instance, as it is stateless. A DataCrawlerFactory will
usually create a new instance, except when the implementation is stateless.
The MagicMimeTypeIdentifierFactory returns a shared instance that is cached
using a WeakReference, as (1) its constructor does some costly initialization,
(2) the instance consumes an significant amount of memory and (3) the identify
method defined in the MimeTypeIdentifier interface does not alter its state.
In other words: you want to keep the instance around as long as it's used but
also get rid of it when you're done.
</p>
<p>

In some cases the get() method will be called newInstance() when from an
architectural perspective it is vital that a new instance is returned. This is
typically the case for objects that will be configured after being returned by
the factory, e.g. DataSources. For other cases (e.g. DataCrawlers) it will not
matter whether you get a unique instance or not and the decision is then best
left to the XYZFactory implementation. This is expressed by the more neutral
get() method, which makes no assumptions on this matter. If there is ever a
case when it is vital that the instance is shared (haven't encountered one
yet), I would propose a sharedInstance() method.
</p>
<p><b>Fact: calling getXYZ() on a Factory can either return a new instance
or an existing instance, depending on use</b>
</p>
<p>
XYZ implementations are provided as separate OSGi bundles (i.e. separate from
the bundle that provides the XYZ interface itself). An implementation bundle
contains an implementation for both the XYZ and the XYZFactory interface. The
BundleActivator of this bundle should announce that the factory implementation
is an implementation of XYZFactory.
</p>
<p>
As said above, the XYZ interface is part of a separate bundle that only
provides this API to the system. This bundle has no BundleActivator as it does
not register a service, it only provides a service API.
</p>
<p>
Besides the XYZ interface itself, this bundle also contains an XYZRegistry.
The job of a registry is to keep track of all the XYZFactory implementations
that are announced to the OSGi platform. Every time the BundleActivator of an
XYZFactory implementation announces the implementation's existance, the
implementation of the XYZRegistry gets notified about this. More specifically,
the BundleActivator of the XYZRegistryImpl makes sure it gets notifications
from the OSGi platform about new XYZFactory implementations and passes this
information to the XYZRegistryImpl, so that the registry itself is still
completely non-OSGi-specific.
</p>
<p>
When you need an XYZ instance, you approach the XYZRegistry instance (of which
there is only one in the system) with the necessary details (e.g. a MIME type,
a scheme, a DataSource type, etc.) and it will provide you with an appropriate
XYZFactory implementation, if there is any available. This factory will then
provide you with the instance.
</p>
<p>
The XYZRegistryImpl is part of a separate bundle, it should not be provided
with the bundle containing XYZ and XYZRegistry, as there may be some
application-dependent decisions to make in its implementation. For example, a
DataCrawlerRegistryImpl could take a look at on which OS platform the
application is running and prefer an OS-specific DataCrawler (or actually: its
corresponding DataCrawlerFactory) over an OS-independent implementation,
assuming that OS-specific implementations provide better optimizations. In
different domains there may be different strategies for choosing a factory, so
this should not be part of the bundle that defines the XYZ and XYZRegistry
implementations.
</p>
<p>
As you can see in the implementations of our factories and registries, there
is actually no OSGi-specific code in them. The code that gets informed about
new factories and passes them on to the registries are part of the OSGi-
specific BundleActivators. This is the only location where use of OSGi is
assumed. It is always possible to directly instantiate a XYZregistryImpl and
pass it a set of XYZFactory implementations, as you can see in the code
examples. However, then you have to make assumptions on which registry and
factory implementations are available. The BundleActivators automate this
process so that you don't have to embed this knowledge in your application.
E.g., add a new Extractor implementation bundle (a jar file!) to your system
and you automatically can handle the mime types it supports. No line of
existing code then needs to be changed.
</p>
<p><b>Fact: The architecture works without OSGI, but we encourage to use
OSGI for deployment and to provide dynamic binding.</b>
</p>

</body>
</html>
