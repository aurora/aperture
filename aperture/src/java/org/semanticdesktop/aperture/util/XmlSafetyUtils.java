/*
 * Copyright (c) 2008 Aduna and Deutsches Forschungszentrum fuer Kuenstliche Intelligenz DFKI GmbH.
 * All rights reserved.
 * 
 * Licensed under the Academic Free License version 3.0.
 */
package org.semanticdesktop.aperture.util;

import info.aduna.xml.XMLUtil;

import java.io.CharArrayWriter;
import java.io.FilterReader;
import java.io.FilterWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.Iterator;

import org.ontoware.aifbcommons.collection.ClosableIterator;
import org.ontoware.rdf2go.exception.ModelRuntimeException;
import org.ontoware.rdf2go.model.Diff;
import org.ontoware.rdf2go.model.Model;
import org.ontoware.rdf2go.model.ModelIO;
import org.ontoware.rdf2go.model.Statement;
import org.ontoware.rdf2go.model.Syntax;
import org.ontoware.rdf2go.model.impl.AbstractModel;
import org.ontoware.rdf2go.model.impl.DelegatingModel;
import org.ontoware.rdf2go.model.node.BlankNode;
import org.ontoware.rdf2go.model.node.DatatypeLiteral;
import org.ontoware.rdf2go.model.node.LanguageTagLiteral;
import org.ontoware.rdf2go.model.node.Node;
import org.ontoware.rdf2go.model.node.PlainLiteral;
import org.ontoware.rdf2go.model.node.Resource;
import org.ontoware.rdf2go.model.node.URI;
import org.semanticdesktop.aperture.rdf.RDFContainer;
import org.semanticdesktop.aperture.rdf.RDFContainerFactory;
import org.semanticdesktop.aperture.rdf.impl.RDFContainerImpl;

/**
 * A set of utility-methods for dealing with XML-safety.
 * 
 * <p>The XML specification states that all characters in a valid XML document must be taken from
 * a certain set. Defined at:
 * 
 * <p><a href="http://www.w3.org/TR/2006/REC-xml-20060816/#charsets">
 * http://www.w3.org/TR/2006/REC-xml-20060816/#charsets</a>
 * 
 * The methods of this class help remove invalid characters from the output generated by Aperture
 * components.
 */
public class XmlSafetyUtils {
    
    /**
     * Strips all invalid XML Character data chars from the given string. If all characters are valid
     * character data chars, this method will return the same String.
     * <p>
     * This method has been copy-pasted from:
     * <a href="http://repo.aduna-software.org/svn/info.aduna/commons/xml/trunk/src/main/java/info/aduna/xml/XMLUtil.java">
     * here</a> and modified slightly. The original version removed the xml-invalid chars altogether
     * this version substitutes them with spaces
     * @param in the input string
     * @return the input string with all characters that are invalid in xml removed
     */
    public static String makeXmlSafe(String s) {
     // first check if there are any invalid chars
        boolean hasInvalidChars = false;

        int length = s.length();
        for (int i = 0; i < length; i++) {
            if (!XMLUtil.isValidCharacterDataChar(s.charAt(i))) {
                hasInvalidChars = true;
                break;
            }
        }

        if (hasInvalidChars) {
            StringBuilder buffer = new StringBuilder(length);
            for (int i = 0; i < length; i++) {
                char c = s.charAt(i);
                if (XMLUtil.isValidCharacterDataChar(c)) {
                    buffer.append(c);
                } else {
                    // this else block is different from the original aduna-commons-xml method
                    buffer.append(' ');
                }
            }

            return buffer.toString();
        }
        else {
            return s;
        }
    }
       
    /**
     * Strips all invalid XML Character data chars from the given string. It starts the checking at
     * the given offset and checks the substring of the given length. If all characters are valid
     * character data chars, this method will return the same String. If any invalid characters are
     * encountered, this method returns a substring. The content of the returned substring is taken
     * from the original string, starting at the offset off, continuing for len characters, with
     * all XML-invalid characters substituted with spaces.
     * 
     * @param in the input string
     * @param off the offset where the validity checking should begin
     * @param len the length of the substring to be checked
     * @return the required substring with all XML-invalid characters substituted with spaces
     */
    public static String makeXmlSafe(String in, int off, int len) {
        if (off == 0 && len == in.length()) {
            return makeXmlSafe(in);
        } 
        StringBuilder buffer = new StringBuilder(len);
        for (int i = off; i <= len+1; i++) {
            char c = in.charAt(i);
            if (XMLUtil.isValidCharacterDataChar(c)) {
                buffer.append(c);
            } else {
                buffer.append(' ');
            }
        }

        return buffer.toString();
    }
    
    /**
     * Removes all non-valid XML character data chars from the specified char array. If all characters are
     * valid XML character data chars, this method will return the same array. If the method encounters any
     * invalid characters it will return a new array whose contents will be copied from s, with the invalid
     * characters substituted with spaces
     * 
     * @param s the array to be checked
     * @return an array whose content is taken from s, with all XML-invalid characters substituted with spaces
     */
    public static char[] makeXmlSafe(char[] s) {
        return makeXmlSafe(s, 0, s.length);
    }
    
    /**
     * Removes all non-valid XML character data chars from the specified char array and substitutes them with
     * spaces. If all characters are valid character data chars, this method will return the same array. If
     * the method encounters any invalid characters it will return a portion cut from the input array,
     * beginning with the offset off, whose length will be equal to len.
     * 
     * @param s the array to be checked
     * @param off the offset where checking should begin
     * @param len of the sub-array to be checked
     * @return an array whose content is taken from s, with all XML-invalid characters substituted with spaces
     */
    public static char[] makeXmlSafe(char [] s, int off, int len) {
        // first check if there are any invalid chars
        boolean hasInvalidChars = false;

        for (int i = off; i < len; i++) {
            if (!XMLUtil.isValidCharacterDataChar(s[i])) {
                hasInvalidChars = true;
                break;
            }
        }

        if (hasInvalidChars) {
            CharArrayWriter buffer = new CharArrayWriter();
            for (int i = off; i < len; i++) {
                char c = s[i];
                if (XMLUtil.isValidCharacterDataChar(c)) {
                    buffer.append(c);
                } else {
                    buffer.append(' ');
                }
            }

            return buffer.toCharArray();
        }
        else {
            return s;
        }
    }
    
    /**
     * Returns an XML-safe version of the given node. It checks whether the node is an literal, converts the
     * value of that literal to an XML-safe version, constructs a new Literal object and returns it. If no
     * XML-invalid characters are found, the original object is returned. Other kinds of nodes (uris and blank
     * nodes) are always returned without any changes
     * 
     * @param model the model used as the literal factory, in case the method needs to construct a new
     *            XML-safe object
     * @param node the node to be checked
     * @return for URIs, blank nodes and literals without any XML-invalid characters, this method returns the
     *         node passed as the node argument. If the given node is a literal and it has some XML-invalid
     *         characters, a new, XML-safe version is returned
     */
    public static Node makeXmlSafe(Model model, Node node) {
        if (node instanceof DatatypeLiteral) {
            DatatypeLiteral dLit = (DatatypeLiteral)node;
            String oldValue = dLit.getValue();
            String newValue = makeXmlSafe(oldValue);
            if (oldValue == newValue) {
                return node;
            } else {
                return model.createDatatypeLiteral(newValue, dLit.getDatatype());
            }
        } else if (node instanceof LanguageTagLiteral) {
            LanguageTagLiteral ltLit = (LanguageTagLiteral)node;
            String oldValue = ltLit.getValue();
            String newValue = makeXmlSafe(oldValue);
            if (oldValue == newValue) {
                return node;
            } else {
                return model.createLanguageTagLiteral(newValue, ltLit.getLanguageTag());
            }
        } else if (node instanceof PlainLiteral) {
            PlainLiteral pLit = (PlainLiteral)node;
            String oldValue = pLit.getValue();
            String newValue = makeXmlSafe(oldValue);
            if (oldValue == newValue) {
                return node;
            } else {
                return model.createPlainLiteral(newValue);
            }
        } else {
            // we only deal with literal nodes, all other kinds of nodes (URIS and BNodes)
            // are to be left alone
            return node;
        }
    }
    
    /**
     * Returns a statement with the same subject and predicate, but with an XML-safe object. If no problems
     * are detected, this method returns the same statement.
     * 
     * @param model the model used as the literal factory, in case the method needs to construct a new
     *            XML-safe object
     * @param stmt the statement to be checked
     * @return a statement with the same subject and predicate, but with an XML-safe object. If no problems
     *         are detected, this method returns the same statement.
     */
    public static Statement makeXmlSafe(Model model, Statement stmt) {
        Node oldNode = stmt.getObject();
        Node newNode = XmlSafetyUtils.makeXmlSafe(model, oldNode);
        if (oldNode == newNode) {
            return stmt;
        } else {
            return model.createStatement(stmt.getSubject(),
                stmt.getPredicate(), newNode);
        }
    }
    
    /**
     * Wraps the given writer in a filter that ensures that no XML-invalid characters are
     * actually written.
     * @param writer
     * @return an XML-safe version of the writer
     */
    public static Writer wrapXmlSafeWriter(Writer writer) {
        if (! (writer instanceof XmlSafeWriter)) {
            return new XmlSafeWriter(writer);
        } else {
            return writer;
        }
    }
    
    /**
     * Wraps the given reader in a filter that ensures that no XML-invalid characters are
     * actually read.
     * @param reader
     * @return an XML-safe version of the reader
     */
    public static Reader wrapXmlSafeReader(Reader reader) {
        if (! (reader instanceof XmlSafeReader)) {
            return new XmlSafeReader(reader);
        } else {
            return reader;
        }
    }
    
    /**
     * Wraps the given model in a wrapper that ensures that all data passed into this model is free of any
     * characters that are invalid in XML.
     * <p>
     * Note that the current implementation handles the add... methods and the methods that read from readers.
     * Id doesn't handle the update methods {@link AbstractModel#update(Diff)} and {@link 
     * AbstractModel#update(org.ontoware.rdf2go.model.DiffReader)} and the methods that read from input
     * streams i.e. {@link ModelIO#readFrom(java.io.InputStream)},
     * {@link ModelIO#readFrom(java.io.InputStream, Syntax)},
     * {@link ModelIO#readFrom(java.io.InputStream, Syntax, Stsring)}. So it's still possible for XML-invalid
     * characters to sneak in via these channels. The user is advised to take care about this.
     * 
     * @param model
     * @return
     */
    public static Model wrapXmlSafeModel(Model model) {
        if (! (model instanceof XmlSafeModel )) {
            return new XmlSafeModel(model);
        } else {
            return model;
        }
    }
    
    /**
     * Returns an RDFContainer backed by the same model as the given one, describing the same URI as the given
     * one but ensuring that all the data passed into the model is XML-safe i.e. it doesn't conatain any
     * characters that are invalid in XML.
     * 
     * @param container the container to wrap
     * @return an XML-safe version of the given RDFContainer.
     */
    public static RDFContainer wrapXmlSafeRDFContainer(RDFContainer container) {
        if (container instanceof XmlSafeRDFContainer) {
            return container;
        } else if (container instanceof RDFContainerImpl) {
            return new XmlSafeRDFContainer(container.getModel(), 
                container.getDescribedUri(), ((RDFContainerImpl)container).isModelShared());
        } else {
            return new XmlSafeRDFContainer(container.getModel(), 
                container.getDescribedUri());
        }
    }
    
    /**
     * Returns a wrapper around the given factory that guarantees that all the rdf containers created
     * by that factory will be XML-safe
     * @param factory
     * @return
     */
    public static org.semanticdesktop.aperture.accessor.RDFContainerFactory 
        wrapXmlSafeAccessorRDFContainerFactory(
        org.semanticdesktop.aperture.accessor.RDFContainerFactory factory) {
        return new XmlSafeRDFContainerAccessorFactory(factory);
    }
    
    /**
     * Returns a wrapper around the given factory that guarantees that all the rdf containers created
     * by that factory will be XML-safe
     * @param factory
     * @return
     */
    public static org.semanticdesktop.aperture.rdf.RDFContainerFactory
        wrapXmlSafeRDFContainerFactory(
        org.semanticdesktop.aperture.rdf.RDFContainerFactory factory) {
        return new XmlSafeRDFContainerFactory(factory);
    }
    
    // COMMENT - this turned out to be difficult, this idea has been postponed
//  public static OutputStream wrapXmlSafeOutputStream(OutputStream ostream, Charset charset) {
//      throw new UnsupportedOperationException("Not implemented yet");
//  }
}

class XmlSafeReader extends FilterReader {

    /**
     * Creates an XML-safe wrapper around the given reader.
     * @param in
     */
    public XmlSafeReader(Reader in) {
        super(in);
    }

    @Override
    public int read() throws IOException {
        int charRead = in.read();
        if (XMLUtil.isValidCharacterDataChar(charRead)) {
            return charRead;
        } else {
            return ' ';
        }
    }

    @Override
    public int read(char[] cbuf, int off, int len) throws IOException {
        int charsRead = super.read(cbuf, off, len);
        for (int i = off; i < off+charsRead; i++) {
            if (!XMLUtil.isValidCharacterDataChar(cbuf[i])) {
                cbuf[i] = ' ';
            }
        }
        return charsRead;
    }
}

class XmlSafeWriter extends FilterWriter {
    
    /**
     * Wraps the given writer in an XML-safe wrapper
     * @param out the writer to wrap
     */
    protected XmlSafeWriter(Writer out) {
        super(out);
    }

    @Override
    public void write(char[] cbuf, int off, int len) throws IOException {
        char[] ncbuf = XmlSafetyUtils.makeXmlSafe(cbuf, off, len);
        if (ncbuf == cbuf) {
            super.write(cbuf, off, len);
        } else {
            super.write(ncbuf,0,ncbuf.length);
        }
    }

    @Override
    public void write(int c) throws IOException {
        if (XMLUtil.isValidCharacterDataChar(c)) {
            out.write(c);
        } else {
            out.write(' ');
        }
    }

    @Override
    public void write(String str, int off, int len) throws IOException {
        String nstr = XmlSafetyUtils.makeXmlSafe(str,off,len);
        if (nstr == str) {
            super.write(str, off, len);
        } else {
            super.write(nstr,0,nstr.length());
        }
    }  
}


/**
 * An XML-safe wrapper for a model. All the add methods are overridden to ensure that the
 * parameters passed to an underlying model are XML-safe
 */
class XmlSafeModel extends DelegatingModel {
    
    /**
     * Wraps the given model in an XML-safe wrapper
     * @param model the model to wrap
     */
    public XmlSafeModel(Model model) {
        super(model);
    }
        
    public void addAll(Iterator<? extends Statement> it) throws ModelRuntimeException {
        while (it.hasNext()) {
            Statement stmt = it.next();
            addStatement(stmt);
        }
    }
    
    public void addModel(Model modelToAdd) throws ModelRuntimeException {
        ClosableIterator<Statement> iter = null;
        try {
            iter = modelToAdd.iterator();
            addAll(iter);
        } finally {
            closeClosable(iter);
        }
    }

    public Resource addReificationOf(Statement arg0, Resource arg1) {
        return getDelegatedModel().addReificationOf(XmlSafetyUtils.makeXmlSafe(getDelegatedModel(), arg0),arg1);
    }

    public BlankNode addReificationOf(Statement arg0) {
        return getDelegatedModel().addReificationOf(XmlSafetyUtils.makeXmlSafe(getDelegatedModel(),arg0));
    }

    public void addStatement(Resource arg0, URI arg1, Node arg2) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(getDelegatedModel(),arg2));
    }

    public void addStatement(Resource arg0, URI arg1, String arg2, String arg3) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2), arg3);
    }

    public void addStatement(Resource arg0, URI arg1, String arg2, URI arg3) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2), arg3);
    }

    public void addStatement(Resource arg0, URI arg1, String arg2) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2));
    }

    public void addStatement(Statement stmt) throws ModelRuntimeException {
        Statement newStmt = XmlSafetyUtils.makeXmlSafe(getDelegatedModel(), stmt);
        if (newStmt == stmt) {
            getDelegatedModel().addStatement(stmt);
        } else {
            getDelegatedModel().addStatement(newStmt);
        }
    }

    public void addStatement(String arg0, URI arg1, String arg2, String arg3) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2), arg3);
    }

    public void addStatement(String arg0, URI arg1, String arg2, URI arg3) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2), arg3);
    }

    public void addStatement(String arg0, URI arg1, String arg2) throws ModelRuntimeException {
        getDelegatedModel().addStatement(arg0, arg1, XmlSafetyUtils.makeXmlSafe(arg2));
    }

    private void closeClosable(ClosableIterator<Statement> iter) {
        if (iter != null) {
            try {
                iter.close();
            } catch (Exception e) {
                // there is hardly anything we can do at the moment
            }
        }
    }

    @Override
    public void readFrom(Reader in, Syntax syntax, String baseURI) throws IOException, ModelRuntimeException {
        super.readFrom(XmlSafetyUtils.wrapXmlSafeReader(in), syntax, baseURI);
    }

    @Override
    public void readFrom(Reader reader, Syntax syntax) throws ModelRuntimeException, IOException {
        super.readFrom(XmlSafetyUtils.wrapXmlSafeReader(reader), syntax);
    }

    @Override
    public void readFrom(Reader r) throws IOException, ModelRuntimeException {
        super.readFrom(XmlSafetyUtils.wrapXmlSafeReader(r));
    }
}

class XmlSafeRDFContainer extends RDFContainerImpl {
    
    /**
     * Constructs an XML-safe RDFContainer
     * @param model
     * @param describedUri
     * @see RDFContainerImpl#RDFContainerImpl(Model, String)
     */
    public XmlSafeRDFContainer(Model model, String describedUri) {
        super(XmlSafetyUtils.wrapXmlSafeModel(model), describedUri);
    }
    
    /**
     * Constructs an XML-safe RDFContainer
     * @param model
     * @param describedUri
     * @see RDFContainerImpl#RDFContainerImpl(Model, URI)
     */
    public XmlSafeRDFContainer(Model model, URI describedUri) {
        super(XmlSafetyUtils.wrapXmlSafeModel(model), describedUri);
    }

    /**
     * Constructs an XML-safe RDFContainer
     * @param model
     * @param describedUri
     * @param modelShared
     * @see RDFContainerImpl#RDFContainerImpl(Model, String, boolean)
     */
    public XmlSafeRDFContainer(Model model, String describedUri, boolean modelShared) {
        super(XmlSafetyUtils.wrapXmlSafeModel(model), describedUri, modelShared);
    }

    /**
     * Constructs an XML-safe RDFContainer
     * @param model
     * @param describedUri
     * @param modelShared
     * @see RDFContainerImpl#RDFContainerImpl(Model, URI, boolean)
     */
    public XmlSafeRDFContainer(Model model, URI describedUri, boolean modelShared) {
        super(XmlSafetyUtils.wrapXmlSafeModel(model), describedUri, modelShared);
    }
}

class XmlSafeRDFContainerFactory implements RDFContainerFactory {

    private RDFContainerFactory factory;

    /**
     * Creates a new XMLSafe Container Factory
     * @param factory factory to wrap
     */
    public XmlSafeRDFContainerFactory(RDFContainerFactory factory) {
        this.factory = factory;
    }

    public RDFContainer newInstance(String uri) {
        RDFContainer container = factory.newInstance(uri);
        return XmlSafetyUtils.wrapXmlSafeRDFContainer(container);
    }

    public RDFContainer newInstance(URI uri) {
        RDFContainer container = factory.newInstance(uri);
        return XmlSafetyUtils.wrapXmlSafeRDFContainer(container);
    }
}

class XmlSafeRDFContainerAccessorFactory implements org.semanticdesktop.aperture.accessor.RDFContainerFactory {

    private org.semanticdesktop.aperture.accessor.RDFContainerFactory factory;

    /**
     * Creates a new XML-safe accessor RDFContainerFactory
     * @param factory factory to wrap
     */
    public XmlSafeRDFContainerAccessorFactory(org.semanticdesktop.aperture.accessor.RDFContainerFactory factory) {
        this.factory = factory;
    }
    
    public RDFContainer getRDFContainer(URI uri) {
        RDFContainer container = factory.getRDFContainer(uri);
        return XmlSafetyUtils.wrapXmlSafeRDFContainer(container);
    }    
}
